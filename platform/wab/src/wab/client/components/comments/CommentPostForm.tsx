// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import { getSetOfVariantsForViewCtx } from "@/wab/client/components/comments/utils";
import { useUserMentions } from "@/wab/client/components/user-mentions/useUserMentions";
import { useAppCtx } from "@/wab/client/contexts/AppContexts";
import {
  DefaultCommentPostFormProps,
  PlasmicCommentPostForm,
} from "@/wab/client/plasmic/plasmic_kit_comments/PlasmicCommentPostForm";
import { useStudioCtx } from "@/wab/client/studio-ctx/StudioCtx";
import {
  ApiComment,
  CommentThreadId,
  RootCommentData,
  ThreadCommentData,
} from "@/wab/shared/ApiSchema";
import { ensure, spawn } from "@/wab/shared/common";
import { observer } from "mobx-react";
import * as React from "react";
import { useState } from "react";

export type CommentPostFormProps = DefaultCommentPostFormProps & {
  threadId?: CommentThreadId;
  editComment?: ApiComment;
  setIsEditing?: (val: boolean) => void;
};

const CommentPostForm = observer(function CommentPostForm(
  props: CommentPostFormProps
) {
  const { threadId, isEditing, setIsEditing, editComment, ...rest } = props;
  const [value, setValue] = useState(editComment?.body || "");

  const studioCtx = useStudioCtx();

  const commentsCtx = studioCtx.commentsCtx;

  const api = useAppCtx().api;

  const formRef = React.useRef<HTMLFormElement>(null);
  const inputElementId = `comment-post-input-${editComment?.id}`;

  const {
    onKeyHandler,
    onSelectHandler,
    userMentionsPopover,
    handleMentionClick,
  } = useUserMentions({
    value,
    onValueChange: setValue,
    inputSelector: `#${inputElementId}`,
  });

  // Either an existing thread should be selected, or a newThreadTpl should be set.
  if (
    (!commentsCtx.openViewCtx() || !commentsCtx.openThreadTpl()) &&
    !threadId
  ) {
    return null;
  }

  function isValidComment() {
    return (
      value.trim().length > 0 || value.trim() !== editComment?.body?.trim()
    );
  }

  return (
    <>
      <form
        ref={formRef}
        onSubmit={async (e) => {
          e.preventDefault();

          if (isEditing && editComment) {
            if (value.trim() !== editComment.body.trim()) {
              spawn(
                api.editComment(
                  commentsCtx.projectId(),
                  commentsCtx.branchId(),
                  editComment.id,
                  {
                    body: value.trim(),
                  }
                )
              );
            }
            setIsEditing?.(false);
            return;
          }

          setValue("");
          if (threadId) {
            const commentData: ThreadCommentData = { body: value };
            await api.postThreadComment(
              commentsCtx.projectId(),
              commentsCtx.branchId(),
              threadId,
              commentData
            );
          } else {
            const location = {
              subject: commentsCtx
                .bundler()
                .addrOf(ensure(commentsCtx.openThreadTpl(), "")),
              variants: getSetOfVariantsForViewCtx(
                ensure(commentsCtx.openViewCtx(), ""),
                commentsCtx.bundler()
              ).map((pv) => commentsCtx.bundler().addrOf(pv)),
            };
            const commentData: RootCommentData = { body: value, location };
            await api.postRootComment(
              commentsCtx.projectId(),
              commentsCtx.branchId(),
              commentData
            );
            commentsCtx.closeCommentDialogs();
          }
        }}
      >
        <PlasmicCommentPostForm
          {...rest}
          isEditing={isEditing}
          bodyInput={{
            autoComplete: "off",
            placeholder: "Add a comment",
            textAreaInput: {
              id: inputElementId,
              value,
              rows: 5,
            },
            onChange: (val) => {
              if (val === undefined) {
                // Plexus Input triggers onChange with undefined on first render even if we pass a controlled value
                setValue(isEditing ? editComment?.body || "" : "");
              } else {
                setValue(val);
              }
            },
            onKeyDown: onKeyHandler,
            onSelect: onSelectHandler,
            onBlur: () => {
              if (isEditing) {
                formRef.current?.requestSubmit();
                setIsEditing?.(false);
              }
            },
          }}
          submitButton={{
            htmlType: "submit",
            disabled: !isValidComment(),
          }}
          mentionIcon={{
            onClick: () => {
              handleMentionClick();
            },
          }}
        />
      </form>

      {userMentionsPopover}
    </>
  );
});

export default CommentPostForm;
