import { isValidComboForToken } from "@/wab/shared/Variants";
import { SiteGenHelper } from "@/wab/shared/codegen/codegen-helpers";
import {
  makeCssClassNameForVariantCombo,
  serializeClassExpr,
} from "@/wab/shared/codegen/react-p/class-names";
import { getContextGlobalVariantsWithVariantedTokens } from "@/wab/shared/codegen/react-p/global-variants";
import {
  makeCreateStyleTokensProviderName,
  makeCreateUseStyleTokensName,
  makeCssProjectImportName,
  makePlasmicTokensClassName,
  makePlasmicTokensOverrideClassName,
  makeProjectCssFileName,
  makeProjectModuleImports,
  makeStyleTokensProviderFileName,
  makeStyleTokensProviderName,
  makeTaggedPlasmicDefaultImport,
  makeUseGlobalVariantsName,
  makeUseStyleTokensName,
  projectStyleCssImportName,
} from "@/wab/shared/codegen/react-p/serialize-utils";
import { getReactWebPackageName } from "@/wab/shared/codegen/react-p/utils";
import {
  ExportOpts,
  ProjectModuleBundle,
  StyleTokensProviderBundle,
} from "@/wab/shared/codegen/types";
import {
  embedInTemplateString,
  jsLiteral,
  toVarName,
  wrapInTemplateString,
} from "@/wab/shared/codegen/util";
import { assert, ensure } from "@/wab/shared/common";
import { CssProjectDependencies } from "@/wab/shared/core/sites";
import { Site } from "@/wab/shared/model/classes";
import {
  makeGlobalVariantComboSorter,
  sortedVariantCombos,
} from "@/wab/shared/variant-sort";
import type { SetRequired } from "type-fest";

export function makeStyleTokensProviderBundle(
  site: Site,
  projectId: string,
  cssProjectDependencies: CssProjectDependencies,
  projectModuleBundle: ProjectModuleBundle,
  exportOpts: SetRequired<Partial<ExportOpts>, "targetEnv">
): StyleTokensProviderBundle {
  const module = `
    /* eslint-disable */
    /* tslint:disable */
    // @ts-nocheck
  
    // This code is auto-generated by Plasmic; please do not edit!
    // Plasmic Project: ${projectId}
    // plasmic-unformatted
  
    import { ${makeCreateStyleTokensProviderName()}, ${makeCreateUseStyleTokensName()} } from "${getReactWebPackageName(
    exportOpts
  )}";

    ${makeProjectModuleImports(projectModuleBundle)}
  
    ${makeCssImport(
      projectId,
      projectStyleCssImportName,
      exportOpts,
      makeProjectCssFileName(projectId, exportOpts)
    )}

    ${cssProjectDependencies
      .map((dep) =>
        makeCssImport(
          dep.projectId,
          makeCssProjectImportName(dep.projectName),
          exportOpts,
          makeProjectCssFileName(dep.projectId, exportOpts)
        )
      )
      .join("\n")}
  
    const data = ${projectStyleTokenData(
      site,
      projectId,
      cssProjectDependencies,
      exportOpts
    )};
  
    export const ${makeUseStyleTokensName()} = ${makeCreateUseStyleTokensName()}(
      data,
      ${makeUseGlobalVariantsName()},
    );
  
    export const ${makeStyleTokensProviderName()} = ${makeCreateStyleTokensProviderName()}(
      data,
      ${makeUseGlobalVariantsName()},
    );`;

  return {
    id: projectId,
    module,
    fileName: makeStyleTokensProviderFileName(projectId, exportOpts),
  };
}

function makeCssImport(
  projectId: string,
  importName: string,
  exportOpts: SetRequired<Partial<ExportOpts>, "targetEnv">,
  cssFileName: string
) {
  return exportOpts?.stylesOpts?.scheme === "css-modules"
    ? makeTaggedPlasmicDefaultImport(
        exportOpts.platform === "gatsby"
          ? `* as ${importName}` // gatsby needs star import
          : importName,
        cssFileName,
        projectId,
        "projectcss"
      )
    : "";
}

function projectStyleTokenData(
  site: Site,
  projectId: string,
  cssProjectDependencies: CssProjectDependencies,
  exportOpts: SetRequired<Partial<ExportOpts>, "targetEnv">
) {
  const depMap = new SiteGenHelper(site, false).objToDepMap();
  const hasStyleTokenOverrides = site.styleTokenOverrides.length > 0;
  const baseClassNames = [
    // project plasmic_tokens
    serializeClassExpr(
      exportOpts,
      makePlasmicTokensClassName(projectId, exportOpts)
    ),
    // project plasmic_tokens_override
    ...(hasStyleTokenOverrides
      ? [
          serializeClassExpr(
            exportOpts,
            makePlasmicTokensOverrideClassName(projectId, exportOpts)
          ),
        ]
      : []),
    // dependencies plasmic_tokens
    ...cssProjectDependencies.map((dep) =>
      serializeClassExpr(
        exportOpts,
        makePlasmicTokensClassName(dep.projectId, exportOpts),
        makeCssProjectImportName(dep.projectName)
      )
    ),
  ];

  const contextGlobalVariantCombos =
    getContextGlobalVariantsWithVariantedTokens(site).map((v) => [v]);
  const sorter = makeGlobalVariantComboSorter(site);

  const globalVariantDataEntries = sortedVariantCombos(
    contextGlobalVariantCombos,
    sorter
  )
    .map((vc) => {
      assert(
        isValidComboForToken(vc),
        "Can only build varianted combos with one variant"
      );
      const variant = vc[0];
      const variantName = toVarName(variant.name);
      const variantGroup = ensure(
        variant.parent,
        "Global variants always have parent group"
      );
      const groupName = toVarName(variantGroup.param.variable.name);
      const variantDep = depMap.get(variantGroup);
      const classNameExpr = serializeClassExpr(
        exportOpts,
        makeCssClassNameForVariantCombo(vc, exportOpts),
        variantDep ? makeCssProjectImportName(variantDep.name) : undefined
      );
      return `{
            className: ${classNameExpr},
            groupName: ${jsLiteral(groupName)},
            variant: ${jsLiteral(variantName)},
          }`;
    })
    .join(",\n");

  const baseArg = wrapInTemplateString(
    baseClassNames.map(embedInTemplateString).join(" ")
  );

  const variantedArg = `[
    ${globalVariantDataEntries}
  ]`;

  return `{
    base: ${baseArg},
    varianted: ${variantedArg},
  }`;
}
